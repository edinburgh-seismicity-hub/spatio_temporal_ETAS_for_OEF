p2 <- plot(fit0, 's1') + xlab(expression(beta[1]))
p3 <- plot(fit0, 's2') + xlab(expression(beta[2]))
p4 <- plot(fit0, 'Precision for the Gaussian observations') + xlab(expression(tau))
multiplot(p1, p2, p3, p4, layout = matrix(c(1,2,3,4), byrow = TRUE, ncol = 2))
SPDEtoy = rbind(SPDEtoy, SPDEtoy[200,])
tail(SPDEtoy)
fm1 = y ~ Intercept +
smooth1(map = s1, values = sort(unique(SPDEtoy$s1)),
model = 'rw1', scale.model = T) +
smooth2(map = s2, values = sort(unique(SPDEtoy$s2)),
model = 'rw1', scale.model = T)
fit1 <- bru(fm1, family = 'Gaussian', data = SPDEtoy)
fm1 = y ~ Intercept +
smooth1(main = s1, values = sort(unique(SPDEtoy$s1)),
model = 'rw1', scale.model = T) +
smooth2(main = s2, values = sort(unique(SPDEtoy$s2)),
model = 'rw1', scale.model = T)
fit1 <- bru(fm1, family = 'Gaussian', data = SPDEtoy)
summary(fit1)
head(SPDEtoy)
par(mfrow = c(1,1))
plot(m1$summary.random$s1$mean)
summary(fit1)
# page 4 - 36
# function to adjust color scale
colsc <- function(...) {
scale_fill_gradientn(colours = rev(RColorBrewer::brewer.pal(11,"RdYlBu")),
limits = range(..., na.rm=TRUE))
}
# Import Data
data(SPDEtoy)
SPDEtoy.sp <- SPDEtoy
coordinates(SPDEtoy.sp) <- ~ s1 + s2
bubble(SPDEtoy.sp, "y", key.entries = c(5, 7.5, 10, 12.5, 15),
maxsize = 2, xlab = "s1", ylab = "s2")
fm1 = y ~ Intercept +
smooth1(main = s1, values = sort(unique(SPDEtoy$s1)),
model = 'rw1', scale.model = T) +
smooth2(main = s2, values = sort(unique(SPDEtoy$s2)),
model = 'rw1', scale.model = T)
fit1 <- bru(fm1, family = 'Gaussian', data = SPDEtoy)
summary(fit1)
par(mfrow = c(1,1))
plot(m1$summary.random$s1$mean)
plot(fit1$summary.random$s1$mean)
plot(fit1, 'random.effect')
plot(fit1, 'mean')
plot(fit1, 'Intercept')
plot(fit1, 'Precision')
plot(fit1, 'Precision for Gaussian observations')
plot(fit1, 'Precision for the Gaussian observations')
plot(fit1, 'Precision for the smooth1')
plot(fit1, 'Precision for smooth1')
plot(fit1, 'Precision for smooth2')
plot(fit1, 'smooth1')
plot(fit1, 'smooth3')
plot(fit1, 'smooth2')
head(SPDEtoy)
topred0 <- data.frame(s1 = 0.5, s2 = 0.5)
pred0 <- predict(fit0, topred0, y ~ s1 + s2 + Intercept)
pred0
?bru
fit2 <- bru(fm1, family = 'Gaussian', data = SPDEtoy,
options = list(control.compute = list(dic = TRUE)))
fit2$dic$dic
fit1$dic$dic
str(fit1$dic)
str(fit2$dic)
Y = matrix(NA, ncol = 2, nrow = 100*2)
data.frame(Y)
# create second data.frame and likelihood
df2 <- data.frame(Y = SPDEtoy$y + rnorm(nrow(SPDEtoy), sd = 2),
s1 = SPDEtoy$s1,
s2 = SPDEtoy$s2)
lik2 <- like(formula = Y ~ s1 + s2,
data = df2,
family = 'Gaussian')
fit2 <- bru(lik1, lik2, components = Y ~ s1 + s2)
lik1 <- like(formula = Y ~ s1 + s2,
data = df1,
family = 'Gaussian')
df1 <- data.frame(Y = SPDEtoy$y,
s1 = SPDEtoy$s1,
s2 = SPDEtoy$s2)
lik1 <- like(formula = Y ~ s1 + s2,
data = df1,
family = 'Gaussian')
# create second data.frame and likelihood
df2 <- data.frame(Y = SPDEtoy$y + rnorm(nrow(SPDEtoy), sd = 2),
s1 = SPDEtoy$s1,
s2 = SPDEtoy$s2)
lik2 <- like(formula = Y ~ s1 + s2,
data = df2,
family = 'Gaussian')
fit2 <- bru(lik1, lik2, components = Y ~ s1 + s2)
summary(fit2)
lik1 <- like(formula = Y ~ s1 + s2 + Intercept,
data = df1,
family = 'Gaussian')
# create second data.frame and likelihood
df2 <- data.frame(Y = SPDEtoy$y + rnorm(nrow(SPDEtoy), sd = 2),
s1 = SPDEtoy$s1,
s2 = SPDEtoy$s2)
lik2 <- like(formula = Y ~ s1 + s2 + Intercept,
data = df2,
family = 'Gaussian')
fit2 <- bru(lik1, lik2, components = Y ~ s1 + s2)
summary(fit2)
setwd("~/SEISMICITY/italy-forecast-models/Forecasts/Time-dependent/Colfiorito_Example")
sessionInfo()
ss <- sessionInfo()
str(ss)
knitr::opts_chunk$set(echo = TRUE)
source('code_for_etas.R')
library(rnaturalearth)
library(ggplot2)
library(viridis)
ss <- sessionInfo()
ss$otherPkgs
sessionInfo()
knitr::opts_chunk$set(echo = TRUE)
source('code_for_etas.R')
library(rnaturalearth)
library(ggplot2)
library(viridis)
# load the data
load('colfiorito.97_99.Rds')
# to plot correctly
# load italy map
it.map <- ne_countries(country = 'Italy', returnclass = "sf", scale = 'medium')
# extract crs
italy.crs <- crs(it.map)
# create sp object
colfiorito.sp.97_99 <- colfiorito.ds.97_99
coordinates(colfiorito.sp.97_99) <- c('Lon', 'Lat')
# create sf object
colfiorito.sf.97_99 <- st_as_sf(colfiorito.sp.97_99)
# project sf object
st_crs(colfiorito.sf.97_99) <- italy.crs#"+proj=longlat +datum=WGS84 +no_defs"#"+proj=utm +zone=33"
colfiorito.sf.97_99 <- st_transform(colfiorito.sf.97_99, italy.crs)
# create Polygon representing study region
x.lims <- c(12, 13.5)
y.lims <- c(42, 44)
x_coords <- c(x.lims[1],x.lims[2],x.lims[2],x.lims[1],x.lims[1])
y_coords <- c(y.lims[1],y.lims[1],y.lims[2],y.lims[2],y.lims[1])
poly1 <- sp::Polygon(cbind(x_coords,y_coords))
bdy <- sp::Polygons(list(poly1), ID = "A")
bdy <- sp::SpatialPolygons(list(bdy))
# create sf object
bdy.sf <- st_as_sf(bdy)
st_crs(bdy.sf) <- italy.crs
bdy.sf <- st_transform(bdy.sf, italy.crs)
# plots
# map with Italy
pl.it <- ggplot() +
geom_sf(data = it.map, fill=alpha("lightgrey", 0), color = 'green') +
geom_sf(data = bdy.sf) +
geom_sf(data = colfiorito.sf.97_99, size = 0.2)
# zoom on the sequence
pl.seq <- ggplot() +
geom_sf(data = bdy.sf) +
geom_sf(data = colfiorito.sf.97_99[order(colfiorito.sf.97_99$Mw),], shape = 21, mapping = aes(fill = Mw)) +
geom_sf(data = colfiorito.sf.97_99[colfiorito.sf.97_99$Mw >= 5,], shape = 24, fill = 'red', size = 2) +
scale_fill_viridis()
# time vs magnitude plot
pl.mag <- ggplot(colfiorito.ds.97_99, aes(x = time_date, y = Mw)) +
geom_point()
# histogram of times
pl.hist <- ggplot(colfiorito.ds.97_99, aes(x = time_date,)) +
geom_histogram(bins = 50)
# actual plot
multiplot(pl.it, pl.seq, pl.mag, pl.hist,
layout = matrix(1:4, ncol = 2, byrow = TRUE))
# preparing df for inlabru to be used later on
# starting date of the sequence (I have chosen this one because the first event is isolated in time)
start.date <- min(colfiorito.ds.97_99$time_date[-1])
# create data.frame (variable names are mandatory)
df.bru <- data.frame(x = colfiorito.ds.97_99$Lon, # x for longitude
y = colfiorito.ds.97_99$Lat, # y for latitude
ts = as.numeric(difftime(colfiorito.ds.97_99$time_date,
start.date,
units = 'days')), # ts for time (in secs, hours, days)
mags = colfiorito.ds.97_99$Mw) # mags for magnitudes
# remove the first two rows (first has negative time and the second has time equal 0)
df.bru <- df.bru[-c(1,2),]
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.05)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# plot log-intensity
ggplot() + gg(pred.bkg['median']) + gg(df.bru.pp) + scale_fill_viridis()
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# plot log-intensity
ggplot() + gg(pred.bkg['median']) + gg(df.bru.pp) + scale_fill_viridis()
mesh_col$n
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.07)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# plot log-intensity
ggplot() + gg(pred.bkg['median']) + gg(df.bru.pp) + scale_fill_viridis()
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
```{r, fig.cap='Estimated background field'}
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
mesh_col$n
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
mesh_col$n
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.11)
mesh_col$n
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# plot log-intensity
ggplot() + gg(pred.bkg['median']) + gg(df.bru.pp) + scale_fill_viridis()
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.15)
mesh_col$n
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# plot log-intensity
ggplot() + gg(pred.bkg['median']) + gg(df.bru.pp) + scale_fill_viridis()
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
mesh_col$n
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
mesh_col$n
knitr::opts_chunk$set(echo = TRUE)
source('code_for_etas.R')
library(rnaturalearth)
library(ggplot2)
library(viridis)
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
bru.bkg$bru_iinla$track
bru.bkg$bru_iinla$states
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.25)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.25)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
df.bru.pp
bdy
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.24)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# plot log-intensity
ggplot() + gg(pred.bkg['median']) + gg(df.bru.pp) + scale_fill_viridis()
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.1)
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.05)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.05)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
cmp <- coordinates ~ field(coordinates, model = spde.o) + Intercept(1)
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb")))
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# value of the bkg field at pixel coordinates (for plotting only)
pred.bkg <- predict(bru.bkg, pixels(mesh_col), ~ field + Intercept)
# plot log-intensity
ggplot() + gg(pred.bkg['median']) + gg(df.bru.pp) + scale_fill_viridis()
# fit the model - takes around 50 secs
bru.bkg <- lgcp(components = cmp,
data = df.bru.pp,
samplers = bdy,
domain = list(coordinates = mesh_col),
options = list(inla.mode = 'experimental',
control.inla = list(int.strategy = "eb",
num.threads= 3)))
# contruct the mesh
mesh_col <- inla.mesh.2d(boundary = bdy, max.edge = 0.05)
# transform data in SpatialPointsDataFrame
df.bru.pp <- df.bru
coordinates(df.bru.pp) <- c('x', 'y')
# set the spde object and the components
spde.o <- inla.spde2.pcmatern(mesh_col,
prior.sigma = c(0.1, 0.01),
prior.range = c(0.01, 0.01))
